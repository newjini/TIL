# 8. 폼
> HTML 폼 엘리먼트는 폼 엘리먼트 자체가 내부 상태를 가지기 때문에, React의 다른 DOM 엘리먼트와 다르게 동작한다. 예를 들어, 순수한 HTML에서 이 폼은 name을 입력받는다.
> 

```jsx
<form>
	<label>
		Name:
		<input type="text" name="name" />
	</label>
	<input type="submit" value="Submit" />
</form>
```

이 폼은 사용자가 폼을 제출하면 새로운 페이지로 이동하는 기본 HTML 폼 동작을 수행한다. React에서 동일한 동작을 원한다면 그대로 사용하면 된다. 그러나 대부분의 경우, JavsScript 함수로 폼의 제출을 처리하고 사용자가 폼에 입력한 데이터에 접근하도록 하는 것이 편리하다. 이를 위한 표준 방식은 `"제어 컴포넌트(controlled components)"`라고 불리는 기술을 이용하는 것이다.
### 1. 제어 컴포넌트 ( Controlled Component )

HTML에서 `<input>, <textarea>, <select>`와 같은 폼 엘리먼트는 일반적으로 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트한다. React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 `setState()`에 의해 업데이트 된다.

React state를 `“신뢰 가능한 단일 출처(single source of truth)”`로 만들어 두 요소를 결합할 수 있다. 그러면 폼을 렌더링하는 React 컴포넌트는 폼에 발생하는 사용자 입력값을 제어한다. 이러한 방식으로 React에 의해 값이 제어되는 입력 폼 엘리먼트를 `“제어 컴포넌트(controlled component)”`라고 한다.

예를 들어, 위의 form 예시가 전송될 때 이름을 기록하길 원한다면 폼을 제어 컴포넌트(controlled component)로 작성할 수 있다.

```jsx
class NameForm extends React.Component {
	constructor(props) {
		super(props);
		this.state = {value: ''};
		this.handleChange = this.handleChange.bind(this);
		this.handleSubmit = this.handleSubmit.bind(this);
	}
	handleChange(event) {
		this.setState({value: event.target.value});
	}
	handleSubmit(event) {
		alert('A name was submitted: ' + this.state.value);
		event.preventDefault();
	}
	render() {
		return (
			<form onSubmit={this.handleSubmit}>
				<label>
					Name:
					<input type="text" value={this.state.value} onChange={this.handleChange} />
				</label>
				<input type="submit" value="Submit" />
			</form>
		);
	}
}
```

`value` 어트리뷰트는 폼 엘리먼트에 설정되므로 표시되는 값은 항상 `this.state.value`가 되고 React state는 신뢰 가능한 단일 출처(single source of truth)가 된다. React state를 업데이트하기 위해 모든 키 입력에서 `handleChange`가 동작하기 때문에 사용자가 입력할 때 보여지는 값이 업데이트된다.

`제어 컴포넌트`로 사용하면, **input의 값은 항상 React state에 의해 결정**된다. 코드를 조금 더 작성해야 한다는 의미지만, 다른 UI 엘리먼트에 input의 값을 전달하거나 다른 이벤트 핸들러에서 값을 재설정할 수 있다.
### 2. textarea 태그

HTML에서 `<textarea>` 엘리먼트는 텍스트를 **자식으로 정의**한다.

```jsx
<textarea>
	Hi there, this is some text in a text area
</textarea>
```

React에서 `<textarea>`는 `value` 어트리뷰트를 대신 사용한다. 이렇게 하면 `<textarea>`를 사용하는 폼은 한 줄 입력을 사용하는 폼과 비슷하게 작성할 수 있다.

```jsx
class EssayForm extends React.Component {
	constructor(props){
		super(props);
		this.state = {
			value: 'Please write an essay about your favorite DOM element.'
		};
		this.handleChange = this.handleChange.bind(this);
		this.handleSubmit = this.handleSubmit.bind(this);
	}
	handleChange(event) {
		this.setState({value: event.target.value});
	}
	handleSubmit(event) {
		alert('An essay was submitted: '+this.state.value);
		event.preventDefault();
	}
	render() {
		return (
			<form onSubmit={this.handleSubmit}>
				<label>
					Essay:
					<textarea value={this.state.value} onChange={this.handleChange} />
				</label>
				<input type="submit" value="Submit" />
			</form>
		);
	}
}
```

`this.state.value`를 생성자에게 초기화하므로 textarea는 일부 텍스트를 가진 채 시작되는 점을 주의하자.
### 3. select 태그

HTML에서 `<select>`는 드롭 다운 목록을 만든다. 예를 들어, 이 HTML은 과일 드롭 다운 목록을 만든다.

```jsx
<select>
    <option value="grapefruit">Grapefruit</option>
	<option value="lime">Lime</option>
	<option selected value="coconut">Coconut</option>
	<option value="mango">Mango</option>
</select>
```

`selected`옵션이 있으므로 Coconut 옵션이 초기값이 되는 점을 주의하자.

React에서는 `selected` 어트리뷰트를 사용하는 대신 최상단 `select`태그에 `value` 어트리뷰트를 사용한다. 한 곳에서 업데이트만 하면 되기 때문에 제어 컴포넌트에서 사용하기 편하다.
### [ 예시 ]
```jsx
class FlavorForm extends React.Component {
	constructor(props) {
		super(props);
		this.state = {value: 'coconut'};
		this.handleChange = this.handleChange.bind(this);
		this.handleSubmit = this.handleSubmit.bind(this);
	}
	handleChange(event) {
		this.setState({value: event.target.value});
	}
	handleSubmit(event) {
		alert('Your favorite flavor is: ' + this.state.value);
		event.preventDefault();
	}
	render() {
		return (
			<form onSubmit={this.handleSubmit}>
				<label>
					Pick your favorite flavor:
					<select value={this.state.value} onChange={this.handleChange}>
                        <option value="grapefruit">Grapefruit</option>
                        <option value="lime">Lime</option>
                        <option value="coconut">Coconut</option>
                        <option value="mango">Mango</option>
					</select>
				</label>
				<input type="submit" value="Submit" />
			</form>
		);
	}
}
```

전반적으로 `<input type="text">, <textarea> 및 <select>` 모두 매우 비슷하게 동작한다. 모두 제어 컴포넌트를 구현하는 데 `value` 어트리뷰트를 허용한다.

### 🤚주의

`select` 태그에 multiple 옵션을 허용한다면 `value` 어트리뷰트에 배열을 전달 할 수 있다.

```jsx
<select multiple={true} value={['B', 'C']}>
```

### 4. file input 태그

HTML에서 `<input type="file">`는 사용자가 하나 이상의 파일을 자신의 장치 저장소에서 서버로 업로드하거나 File API를 통해 JavaScript로 조작할 수 있다.

```jsx
<input type="file" />
```

값이 읽기 전용이기 때문에 React에서는 **비제어 컴포넌트**다. 

### 5. 다중 입력 제어하기

여러 `input` 엘리먼트를 제어해야 할 때, 각 엘리먼트에 `name` 어트리뷰트를 추가하고 `[event.target.name](http://event.target.name)` 값을 통해 핸들러가 어떤 작업을 할 지 선택할 수 있게 해준다.

### [ 예시 ]

```jsx
class Reservation extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			isGoing: true,
			numberOfGuests: 2
		};
		this.handleInputChange = this.handleInputChange.bind(this);
	}
	handleInputChange(event) {
		const target = event.target;
		const value = target.type === 'checkbox' ? target.checked : target.value;
		const name = target.name;
		this.setState({
			[name]: value
		});
	}
	render() {
		return (
			<form>
				<label>
					Is going:
					<input
						name="isGoing"
						type="checkbox"
						checked={this.state.isGoing}
						onChange={this.handleInputChange} />
				</label>
				<br />
				<label>
					Number of guests:
					<input
						name="numberOfGuests"
						type="number"
						value={this.state.numberOGuests}
						onChange={this.handleInputChange} />
				</label>
			</form>
		);
	}
}
```

주어진 input 태그의 name에 일치하는 state를 업데이트하기 위해 ES6의 `computed property name` 구문을 사용하고 있다.

```jsx
this.setState({
	[name]: value
});

// ES5 코드는 아래와 같다.
var partialState = {};
partialState[name] = value;
this.setState(partialState);
```

또한, `setState()`는 자동적으로 `현재 state에 일부 state를 병합`하기 때문에 바뀐 부분에 대해서만 호출하면 된다.